<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/0-Tests/Bernhoeft.GRT.Teste.IntegrationTests/Bernhoeft.GRT.Teste.IntegrationTests.csproj">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/0-Tests/Bernhoeft.GRT.Teste.IntegrationTests/Bernhoeft.GRT.Teste.IntegrationTests.csproj" />
              <option name="originalContent" value="&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;&#10;&#10;  &lt;PropertyGroup&gt;&#10;    &lt;TargetFramework&gt;net9.0&lt;/TargetFramework&gt;&#10;    &lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;&#10;  &lt;/PropertyGroup&gt;&#10;&#10;  &lt;ItemGroup&gt;&#10;    &lt;PackageReference Include=&quot;Bogus&quot; Version=&quot;35.6.2&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;FluentAssertions&quot; Version=&quot;8.1.1&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Microsoft.AspNetCore.Mvc.Testing&quot; Version=&quot;9.0.2&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Microsoft.EntityFrameworkCore.InMemory&quot; Version=&quot;9.0.2&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Microsoft.NET.Test.Sdk&quot; Version=&quot;17.13.0&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;SeedEasy&quot; Version=&quot;2.0.3&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Soenneker.Utils.AutoBogus&quot; Version=&quot;3.0.689&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;xunit&quot; Version=&quot;2.9.3&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Xunit.Priority&quot; Version=&quot;1.1.6&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;xunit.runner.visualstudio&quot; Version=&quot;3.0.2&quot;&gt;&#10;      &lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;&#10;      &lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;&#10;    &lt;/PackageReference&gt;&#10;  &lt;/ItemGroup&gt;&#10;&#10;  &lt;ItemGroup&gt;&#10;    &lt;ProjectReference Include=&quot;..\..\1-Presentation\Bernhoeft.GRT.Teste.Api\Bernhoeft.GRT.Teste.Api.csproj&quot; /&gt;&#10;  &lt;/ItemGroup&gt;&#10;&#10;    &lt;/Reference&gt;&#10;  &lt;/ItemGroup&gt;&#10;&#10;&lt;/Project&gt;&#10;" />
              <option name="updatedContent" value="&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;&#10;&#10;  &lt;PropertyGroup&gt;&#10;    &lt;TargetFramework&gt;net9.0&lt;/TargetFramework&gt;&#10;    &lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;&#10;  &lt;/PropertyGroup&gt;&#10;&#10;  &lt;ItemGroup&gt;&#10;    &lt;PackageReference Include=&quot;Bogus&quot; Version=&quot;35.6.2&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;FluentAssertions&quot; Version=&quot;8.1.1&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Microsoft.AspNetCore.Mvc.Testing&quot; Version=&quot;9.0.2&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Microsoft.EntityFrameworkCore.InMemory&quot; Version=&quot;9.0.2&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Microsoft.NET.Test.Sdk&quot; Version=&quot;17.13.0&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;SeedEasy&quot; Version=&quot;2.0.3&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Soenneker.Utils.AutoBogus&quot; Version=&quot;3.0.689&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;xunit&quot; Version=&quot;2.9.3&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Xunit.Priority&quot; Version=&quot;1.1.6&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;xunit.runner.visualstudio&quot; Version=&quot;3.0.2&quot;&gt;&#10;      &lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;&#10;      &lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;&#10;    &lt;/PackageReference&gt;&#10;  &lt;/ItemGroup&gt;&#10;&#10;  &lt;ItemGroup&gt;&#10;    &lt;ProjectReference Include=&quot;..\..\1-Presentation\Bernhoeft.GRT.Teste.Api\Bernhoeft.GRT.Teste.Api.csproj&quot; /&gt;&#10;  &lt;/ItemGroup&gt;&#10;&#10;  &lt;ItemGroup&gt;&#10;    &lt;Reference Include=&quot;Bernhoeft.GRT.Core&quot;&gt;&#10;      &lt;HintPath&gt;..\..\Libs\Bernhoeft.GRT.Core.dll&lt;/HintPath&gt;&#10;    &lt;/Reference&gt;&#10;    &lt;Reference Include=&quot;Bernhoeft.GRT.Core.EntityFramework&quot;&gt;&#10;      &lt;HintPath&gt;..\..\Libs\Bernhoeft.GRT.Core.EntityFramework.dll&lt;/HintPath&gt;&#10;    &lt;/Reference&gt;&#10;  &lt;/ItemGroup&gt;&#10;&#10;&lt;/Project&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/0-Tests/Bernhoeft.GRT.Teste.IntegrationTests/Infra/Repositories/AvisoRepository/AvisoRepositoryTest.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/0-Tests/Bernhoeft.GRT.Teste.IntegrationTests/Infra/Repositories/AvisoRepository/AvisoRepositoryTest.cs" />
              <option name="originalContent" value="using Bernhoeft.GRT.ContractWeb.Domain.SqlServer.ContractStore.Interfaces.Repositories;&#10;using Xunit;&#10;&#10;namespace Bernhoeft.GRT.Teste.IntegrationTests.Infra.Repositories.AvisoRepository;&#10;&#10;[Collection(nameof(AvisoRepositoryTest))]&#10;public class AvisoRepositoryTest&#10;{&#10;    private readonly IAvisoRepository _avisoRepository;&#10;    private readonly AvisoRepositoryTestFixture _fixture;&#10;&#10;    public AvisoRepositoryTest(IAvisoRepository avisoRepository, AvisoRepositoryTestFixture fixture)&#10;    {&#10;        _avisoRepository = avisoRepository;&#10;        _fixture = fixture;&#10;    }&#10;&#10;    [Fact]&#10;    public async Task Teste_AvisoRepository_Deve_ObterTodosAvisosAsync()&#10;    {&#10;        // Arrange&#10;        var aviso = _fixture.GerarAvisoValido();&#10;        await _avisoRepository.CriarAvisoAsync(aviso);&#10;&#10;        // Act&#10;        var avisos = await _avisoRepository.ObterTodosAvisosAsync();&#10;&#10;        // Assert&#10;        Assert.NotNull(avisos);&#10;        Assert.Contains(avisos, a =&gt; a.Id == aviso.Id);&#10;    }&#10;&#10;    [Fact]&#10;    public async Task Teste_AvisoRepository_Deve_ObterApenasAvisosAtivos()&#10;    {&#10;        // Arrange&#10;        var avisoAtivo = _fixture.GerarAvisoValido();&#10;        await _avisoRepository.CriarAvisoAsync(avisoAtivo);&#10;&#10;        var avisoInativo = _fixture.GerarAvisoValido();&#10;        await _avisoRepository.CriarAvisoAsync(avisoInativo);&#10;        await _avisoRepository.DeletarAvisoAsync(avisoInativo.Id);&#10;&#10;        // Act&#10;        var avisos = await _avisoRepository.ObterTodosAvisosAsync();&#10;&#10;        // Assert&#10;        Assert.NotNull(avisos);&#10;        Assert.Contains(avisos, a =&gt; a.Id == avisoAtivo.Id);&#10;        Assert.DoesNotContain(avisos, a =&gt; a.Id == avisoInativo.Id);&#10;    }&#10;&#10;    [Fact]&#10;    public async Task Teste_AvisoRepository_Deve_ObterAvisoPorIdAsync()&#10;    {&#10;        // Arrange&#10;        var aviso = _fixture.GerarAvisoValido();&#10;        await _avisoRepository.CriarAvisoAsync(aviso);&#10;&#10;        // Act&#10;        var avisoObtido = await _avisoRepository.ObterAvisoPorIdAsync(aviso.Id);&#10;&#10;        // Assert&#10;        Assert.NotNull(avisoObtido);&#10;        Assert.Equal(aviso.Id, avisoObtido.Id);&#10;    }&#10;&#10;    [Fact]&#10;    public async Task Teste_AvisoRepository_Deve_AtualizarAvisoAsync()&#10;    {&#10;        // Arrange&#10;        var aviso = _fixture.GerarAvisoValido();&#10;        await _avisoRepository.CriarAvisoAsync(aviso);&#10;&#10;        var novoTitulo = _fixture.GerarTituloValido();&#10;        aviso.Titulo = novoTitulo;&#10;&#10;        // Act&#10;        await _avisoRepository.AtualizarAvisoAsync(aviso);&#10;        var avisoAtualizado = await _avisoRepository.ObterAvisoPorIdAsync(aviso.Id);&#10;&#10;        // Assert&#10;        Assert.NotNull(avisoAtualizado);&#10;        Assert.Equal(novoTitulo, avisoAtualizado.Titulo);&#10;    }&#10;&#10;    [Fact]&#10;    public async Task Teste_AvisoRepository_Deve_DeletarAvisoAsync()&#10;    {&#10;        // Arrange&#10;        var aviso = _fixture.GerarAvisoValido();&#10;        await _avisoRepository.CriarAvisoAsync(aviso);&#10;&#10;        // Act&#10;        await _avisoRepository.DeletarAvisoAsync(aviso.Id);&#10;        var avisoDeletado = await _avisoRepository.ObterAvisoPorIdAsync(aviso.Id);&#10;&#10;        // Assert&#10;        Assert.NotNull(avisoDeletado);&#10;        Assert.False(avisoDeletado.Ativo);&#10;    }&#10;&#10;    [Fact]&#10;    public async Task Teste_AvisoRepository_Deve_LancarExcecaoAoDeletarAvisoInexistente()&#10;    {&#10;        // Arrange&#10;        var avisoInexistenteId = -1;&#10;&#10;        // Act &amp; Assert&#10;        await Assert.ThrowsAsync&lt;Exception&gt;(async () =&gt;&#10;        {&#10;            await _avisoRepository.DeletarAvisoAsync(avisoInexistenteId);&#10;        });&#10;    }&#10;&#10;    [Fact]&#10;    public async Task Teste_AvisoRepository_Deve_CriarAvisoAsync()&#10;    {&#10;        // Arrange&#10;        var aviso = _fixture.GerarAvisoValido();&#10;&#10;        // Act&#10;        await _avisoRepository.CriarAvisoAsync(aviso);&#10;        var avisoCriado = await _avisoRepository.ObterAvisoPorIdAsync(aviso.Id);&#10;&#10;        // Assert&#10;        Assert.NotNull(avisoCriado);&#10;        Assert.Equal(aviso.Titulo, avisoCriado.Titulo);&#10;        Assert.Equal(aviso.Mensagem, avisoCriado.Mensagem);&#10;    }&#10;}" />
              <option name="updatedContent" value="using Bernhoeft.GRT.ContractWeb.Domain.SqlServer.ContractStore.Interfaces.Repositories;&#10;using Xunit;&#10;&#10;namespace Bernhoeft.GRT.Teste.IntegrationTests.Infra.Repositories.AvisoRepository;&#10;&#10;[Collection(&quot;AvisoRepositoryTestCollection&quot;)]&#10;public class AvisoRepositoryTest : IClassFixture&lt;AvisoRepositoryTestFixture&gt;&#10;{&#10;    private readonly IAvisoRepository _avisoRepository;&#10;    private readonly AvisoRepositoryTestFixture _fixture;&#10;&#10;    public AvisoRepositoryTest(AvisoRepositoryTestCollectionFixture collectionFixture, AvisoRepositoryTestFixture fixture)&#10;    {&#10;        _avisoRepository = (IAvisoRepository)collectionFixture.ServiceProvider.GetService(typeof(IAvisoRepository));&#10;        _fixture = fixture;&#10;    }&#10;&#10;    [Fact]&#10;    public async Task Teste_AvisoRepository_Deve_ObterTodosAvisosAsync()&#10;    {&#10;        // Arrange&#10;        var aviso = _fixture.GerarAvisoValido();&#10;        await _avisoRepository.CriarAvisoAsync(aviso);&#10;&#10;        // Act&#10;        var avisos = await _avisoRepository.ObterTodosAvisosAsync();&#10;&#10;        // Assert&#10;        Assert.NotNull(avisos);&#10;        Assert.Contains(avisos, a =&gt; a.Id == aviso.Id);&#10;    }&#10;&#10;    [Fact]&#10;    public async Task Teste_AvisoRepository_Deve_ObterApenasAvisosAtivos()&#10;    {&#10;        // Arrange&#10;        var avisoAtivo = _fixture.GerarAvisoValido();&#10;        await _avisoRepository.CriarAvisoAsync(avisoAtivo);&#10;&#10;        var avisoInativo = _fixture.GerarAvisoValido();&#10;        await _avisoRepository.CriarAvisoAsync(avisoInativo);&#10;        await _avisoRepository.DeletarAvisoAsync(avisoInativo.Id);&#10;&#10;        // Act&#10;        var avisos = await _avisoRepository.ObterTodosAvisosAsync();&#10;&#10;        // Assert&#10;        Assert.NotNull(avisos);&#10;        Assert.Contains(avisos, a =&gt; a.Id == avisoAtivo.Id);&#10;        Assert.DoesNotContain(avisos, a =&gt; a.Id == avisoInativo.Id);&#10;    }&#10;&#10;    [Fact]&#10;    public async Task Teste_AvisoRepository_Deve_ObterAvisoPorIdAsync()&#10;    {&#10;        // Arrange&#10;        var aviso = _fixture.GerarAvisoValido();&#10;        await _avisoRepository.CriarAvisoAsync(aviso);&#10;&#10;        // Act&#10;        var avisoObtido = await _avisoRepository.ObterAvisoPorIdAsync(aviso.Id);&#10;&#10;        // Assert&#10;        Assert.NotNull(avisoObtido);&#10;        Assert.Equal(aviso.Id, avisoObtido.Id);&#10;    }&#10;&#10;    [Fact]&#10;    public async Task Teste_AvisoRepository_Deve_AtualizarAvisoAsync()&#10;    {&#10;        // Arrange&#10;        var aviso = _fixture.GerarAvisoValido();&#10;        await _avisoRepository.CriarAvisoAsync(aviso);&#10;&#10;        var novoTitulo = _fixture.GerarTituloValido();&#10;        aviso.Titulo = novoTitulo;&#10;&#10;        // Act&#10;        await _avisoRepository.AtualizarAvisoAsync(aviso);&#10;        var avisoAtualizado = await _avisoRepository.ObterAvisoPorIdAsync(aviso.Id);&#10;&#10;        // Assert&#10;        Assert.NotNull(avisoAtualizado);&#10;        Assert.Equal(novoTitulo, avisoAtualizado.Titulo);&#10;    }&#10;&#10;    [Fact]&#10;    public async Task Teste_AvisoRepository_Deve_DeletarAvisoAsync()&#10;    {&#10;        // Arrange&#10;        var aviso = _fixture.GerarAvisoValido();&#10;        await _avisoRepository.CriarAvisoAsync(aviso);&#10;&#10;        // Act&#10;        await _avisoRepository.DeletarAvisoAsync(aviso.Id);&#10;        var avisoDeletado = await _avisoRepository.ObterAvisoPorIdAsync(aviso.Id);&#10;&#10;        // Assert&#10;        Assert.NotNull(avisoDeletado);&#10;        Assert.False(avisoDeletado.Ativo);&#10;    }&#10;&#10;    [Fact]&#10;    public async Task Teste_AvisoRepository_Deve_LancarExcecaoAoDeletarAvisoInexistente()&#10;    {&#10;        // Arrange&#10;        var avisoInexistenteId = -1;&#10;&#10;        // Act &amp; Assert&#10;        await Assert.ThrowsAsync&lt;Exception&gt;(async () =&gt;&#10;        {&#10;            await _avisoRepository.DeletarAvisoAsync(avisoInexistenteId);&#10;        });&#10;    }&#10;&#10;    [Fact]&#10;    public async Task Teste_AvisoRepository_Deve_CriarAvisoAsync()&#10;    {&#10;        // Arrange&#10;        var aviso = _fixture.GerarAvisoValido();&#10;&#10;        // Act&#10;        await _avisoRepository.CriarAvisoAsync(aviso);&#10;        var avisoCriado = await _avisoRepository.ObterAvisoPorIdAsync(aviso.Id);&#10;&#10;        // Assert&#10;        Assert.NotNull(avisoCriado);&#10;        Assert.Equal(aviso.Titulo, avisoCriado.Titulo);&#10;        Assert.Equal(aviso.Mensagem, avisoCriado.Mensagem);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/0-Tests/Bernhoeft.GRT.Teste.IntegrationTests/Infra/Repositories/AvisoRepository/AvisoRepositoryTestCollectionFixture.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/0-Tests/Bernhoeft.GRT.Teste.IntegrationTests/Infra/Repositories/AvisoRepository/AvisoRepositoryTestCollectionFixture.cs" />
              <option name="updatedContent" value="using System;&#10;using Bernhoeft.GRT.ContractWeb.Domain.SqlServer.ContractStore.Interfaces.Repositories;&#10;using Bernhoeft.GRT.Teste.Infra.Persistence.InMemory.Repositories;&#10;using Microsoft.EntityFrameworkCore;&#10;using Microsoft.Extensions.DependencyInjection;&#10;using Xunit;&#10;&#10;public class AvisoRepositoryTestCollectionFixture : IDisposable&#10;{&#10;    public ServiceProvider ServiceProvider { get; }&#10;&#10;    public AvisoRepositoryTestCollectionFixture()&#10;    {&#10;        var services = new ServiceCollection();&#10;        services.AddDbContext&lt;TestDbContext&gt;(options =&gt;&#10;            options.UseInMemoryDatabase(&quot;integration-tests-db&quot;));&#10;        services.AddScoped&lt;DbContext&gt;(provider =&gt; provider.GetRequiredService&lt;TestDbContext&gt;());&#10;        services.AddScoped&lt;IAvisoRepository, AvisoRepository&gt;();&#10;        ServiceProvider = services.BuildServiceProvider();&#10;    }&#10;&#10;    public void Dispose()&#10;    {&#10;        ServiceProvider?.Dispose();&#10;    }&#10;}&#10;&#10;[CollectionDefinition(&quot;AvisoRepositoryTestCollection&quot;)]&#10;public class AvisoRepositoryTestCollection : ICollectionFixture&lt;AvisoRepositoryTestCollectionFixture&gt;&#10;{&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/0-Tests/Bernhoeft.GRT.Teste.IntegrationTests/Infra/Repositories/AvisoRepository/TestDbContext.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/0-Tests/Bernhoeft.GRT.Teste.IntegrationTests/Infra/Repositories/AvisoRepository/TestDbContext.cs" />
              <option name="updatedContent" value="using Microsoft.EntityFrameworkCore;&#10;using Bernhoeft.GRT.ContractWeb.Domain.SqlServer.ContractStore.Entities;&#10;&#10;namespace Bernhoeft.GRT.Teste.IntegrationTests.Infra.Repositories.AvisoRepository;&#10;&#10;public class TestDbContext : DbContext&#10;{&#10;    public TestDbContext(DbContextOptions&lt;TestDbContext&gt; options) : base(options) { }&#10;    public DbSet&lt;AvisoEntity&gt; Avisos { get; set; }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/0-Tests/Bernhoeft.GRT.Teste.IntegrationTests/Infra/Repositories/AvisoRepositoryTest/AvisoRepositoryTestCollectionFixture.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/0-Tests/Bernhoeft.GRT.Teste.IntegrationTests/Infra/Repositories/AvisoRepositoryTest/AvisoRepositoryTestCollectionFixture.cs" />
              <option name="originalContent" value="    public ServiceProvider ServiceProvider { get; }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="using Bernhoeft.GRT.Teste.Domain.Interfaces.Repositories;&#10;using Bernhoeft.GRT.Teste.Infra.Persistence.InMemory.Repositories;&#10;using Microsoft.EntityFrameworkCore;&#10;using Microsoft.Extensions.DependencyInjection;&#10;using Xunit;&#10;&#10;namespace Bernhoeft.GRT.Teste.IntegrationTests.Infra.Repositories.AvisoRepositoryTest;&#10;&#10;public class AvisoRepositoryTestCollectionFixture : IDisposable&#10;{&#10;    public ServiceProvider ServiceProvider { get; }&#10;&#10;    public AvisoRepositoryTestCollectionFixture()&#10;    {&#10;        var services = new ServiceCollection();&#10;        services.AddDbContext&lt;TestDbContext&gt;(options =&gt;&#10;            options.UseInMemoryDatabase(&quot;integration-tests-db&quot;));&#10;        services.AddScoped&lt;DbContext&gt;(provider =&gt; provider.GetRequiredService&lt;TestDbContext&gt;());&#10;        services.AddScoped&lt;IAvisoRepository, AvisoRepository&gt;();&#10;        ServiceProvider = services.BuildServiceProvider();&#10;    }&#10;&#10;    public void Dispose()&#10;    {&#10;        ServiceProvider?.Dispose();&#10;    }&#10;}&#10;&#10;[CollectionDefinition(&quot;AvisoRepositoryTestCollection&quot;)]&#10;public class AvisoRepositoryTestCollection : ICollectionFixture&lt;AvisoRepositoryTestCollectionFixture&gt;&#10;{&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/0-Tests/Bernhoeft.GRT.Teste.IntegrationTests/Infra/Repositories/AvisoRepositoryTest/TestDbContext.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/0-Tests/Bernhoeft.GRT.Teste.IntegrationTests/Infra/Repositories/AvisoRepositoryTest/TestDbContext.cs" />
              <option name="updatedContent" value="using Microsoft.EntityFrameworkCore;&#10;using Bernhoeft.GRT.Teste.Domain.Entities;&#10;&#10;namespace Bernhoeft.GRT.Teste.IntegrationTests.Infra.Repositories.AvisoRepositoryTest;&#10;&#10;public class TestDbContext : DbContext&#10;{&#10;    public TestDbContext(DbContextOptions&lt;TestDbContext&gt; options) : base(options) { }&#10;    public DbSet&lt;AvisoEntity&gt; Avisos { get; set; }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/1-Presentation/Bernhoeft.GRT.Teste.Api/Program.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/1-Presentation/Bernhoeft.GRT.Teste.Api/Program.cs" />
              <option name="originalContent" value="using System.Diagnostics;&#10;using System.Globalization;&#10;using System.Text.Json.Serialization;&#10;using Bernhoeft.GRT.Core.Extensions;&#10;using Bernhoeft.GRT.Teste.Api.Swashbuckle;&#10;using Bernhoeft.GRT.Teste.Application.Requests.Queries.v1;&#10;using FluentValidation;&#10;using FluentValidation.AspNetCore;&#10;using MicroElements.Swashbuckle.FluentValidation.AspNetCore;&#10;using Microsoft.AspNetCore.Http.Features;&#10;using Microsoft.AspNetCore.HttpOverrides;&#10;using Microsoft.EntityFrameworkCore;&#10;using Microsoft.Extensions.Options;&#10;using Swashbuckle.AspNetCore.SwaggerGen;&#10;using Unchase.Swashbuckle.AspNetCore.Extensions.Extensions;&#10;&#10;var builder = WebApplication.CreateBuilder(args);&#10;&#10;if (Debugger.IsAttached)&#10;    builder.Configuration.AddJsonFile(&quot;appsettings.Debugger.json&quot;, true);&#10;&#10;builder.WebHost.UseKestrel(options =&gt;&#10;{&#10;    options.AddServerHeader = false; /* Header com Informações do Servidor. */&#10;    options.Limits.MaxRequestLineSize = 32 * 1024; /* Tamanho máximo do URL (em bytes). */&#10;    options.Limits.MaxRequestBodySize = 50 * 1024 * 1024; /* Tamanho máximo da solicitação (em bytes). */&#10;    options.Limits.MinResponseDataRate = null; /* Taxa mínima de dados de resposta (bytes/segundo). */&#10;    options.Limits.MinRequestBodyDataRate = null; /* Taxa mínima de dados de solicitação (bytes/segundo). */&#10;    if (int.TryParse(Environment.GetEnvironmentVariable(&quot;PORT&quot;), out var port))&#10;        options.ListenAnyIP(port);&#10;});&#10;&#10;// Adicionando os serviços no container.&#10;builder.Services.AddMemoryCache()&#10;                .AddControllers(options =&gt;&#10;                {&#10;                    options.MaxModelBindingCollectionSize = int.MaxValue;&#10;                    options.CacheProfiles.Add(&quot;DefaultCache&quot;, new CacheProfile&#10;                    {&#10;                        Duration = 3600,&#10;                        Location = ResponseCacheLocation.Client&#10;                    });&#10;                })&#10;                .AddJsonOptions(options =&gt;&#10;                {&#10;                    options.JsonSerializerOptions.DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull;&#10;                    options.JsonSerializerOptions.PropertyNamingPolicy = null;&#10;                });&#10;&#10;builder.Services.AddEndpointsApiExplorer();&#10;&#10;// Configurando o versionamento.&#10;builder.Services.AddApiVersioning(p =&gt;&#10;                {&#10;                    p.DefaultApiVersion = new ApiVersion(1, 0);&#10;                    p.ReportApiVersions = true;&#10;                    p.AssumeDefaultVersionWhenUnspecified = true;&#10;                })&#10;                .AddApiExplorer(p =&gt;&#10;                {&#10;                    p.GroupNameFormat = &quot;'Teste API v'VVV&quot;;&#10;                    p.SubstituteApiVersionInUrl = true;&#10;                });&#10;&#10;builder.Services.AddTransient&lt;IConfigureOptions&lt;SwaggerGenOptions&gt;, ConfigureSwaggerOptions&gt;();&#10;builder.Services.AddSwaggerGen(options =&gt;&#10;{&#10;    options.IgnoreObsoleteProperties();&#10;    options.AddGRTSwaggerGenFilters();&#10;    options.AddEnumsWithValuesFixFilters(option =&gt;&#10;    {&#10;        option.ApplySchemaFilter = true;&#10;        option.ApplyParameterFilter = true;&#10;        option.ApplyDocumentFilter = true;&#10;        option.IncludeDescriptions = true;&#10;        option.IncludeXEnumRemarks = true;&#10;        option.DescriptionSource = DescriptionSources.DescriptionAttributesThenXmlComments;&#10;    });&#10;&#10;    Directory.GetFiles(AppContext.BaseDirectory, &quot;*.xml&quot;).ForEach(xmlFile =&gt;&#10;    {&#10;        options.IncludeXmlComments(xmlFile, true);&#10;    });&#10;});&#10;&#10;// Configurando o MediatR.&#10;builder.Services.AddMediatR(options =&gt; options.RegisterServicesFromAssemblyContaining&lt;GetAvisosRequest&gt;());&#10;&#10;// Adicionar Context de Conexão com Banco de Dados SqlServer GRT.&#10;builder.Services.AddDbContext&lt;DbContext&gt;(options =&gt; options.UseInMemoryDatabase(&quot;TesteDb&quot;));&#10;&#10;// Outros Serviços.&#10;builder.Services.RegisterServicesFromAssemblyContaining&lt;GetAvisosRequest&gt;();&#10;buil&#10;&#10;// Adicionando Fluent Validation.&#10;ValidatorOptions.Global.DefaultClassLevelCascadeMode = CascadeMode.Stop;&#10;ValidatorOptions.Global.DefaultRuleLevelCascadeMode = CascadeMode.Stop;&#10;ValidatorOptions.Global.LanguageManager.Culture = new CultureInfo(&quot;pt-BR&quot;);&#10;builder.Services.AddFluentValidationAutoValidation(options =&gt; options.DisableDataAnnotationsValidation = true)&#10;                .AddFluentValidationClientsideAdapters()&#10;                .AddValidatorsFromAssemblyContaining&lt;GetAvisosRequest&gt;();&#10;builder.Services.AddFluentValidationRulesToSwagger();&#10;&#10;// Configure Some Options&#10;builder.Services.Configure&lt;FormOptions&gt;(options =&gt; options.ValueCountLimit = int.MaxValue)&#10;                .Configure&lt;RouteOptions&gt;(options =&gt; options.LowercaseUrls = true);&#10;&#10;// Configurando a Pipeline do HTTP Request.&#10;var app = builder.Build();&#10;app.UseForwardedHeaders(new()&#10;{&#10;    ForwardedHeaders = ForwardedHeaders.XForwardedFor | ForwardedHeaders.XForwardedProto&#10;});&#10;&#10;if (app.Environment.IsDevelopment() || app.Environment.IsStaging() || Debugger.IsAttached)&#10;{&#10;    app.UseSwagger();&#10;    app.UseSwaggerUI(options =&gt;&#10;    {&#10;        var apiVersionDescriptionProvider = app.Services.GetRequiredService&lt;IApiVersionDescriptionProvider&gt;();&#10;        apiVersionDescriptionProvider?.ApiVersionDescriptions?.Reverse().ForEach(description =&gt;&#10;        {&#10;            options.SwaggerEndpoint($&quot;/swagger/{description.GroupName}/swagger.json&quot;, description.GroupName);&#10;        });&#10;&#10;        options.RoutePrefix = string.Empty;&#10;    });&#10;}&#10;&#10;app.UseCors(options =&gt; options.WithOrigins()&#10;                              .AllowAnyHeader()&#10;                              .AllowAnyMethod()&#10;                              .AllowCredentials()&#10;                              .SetIsOriginAllowed(origin =&gt; true));&#10;app.UseHttpsRedirection();&#10;app.UseAuthentication();&#10;app.UseAuthorization();&#10;app.MapControllers();&#10;await app.RunAsync();&#10;&#10;public partial class Program&#10;{ }" />
              <option name="updatedContent" value="using System.Diagnostics;&#10;using System.Globalization;&#10;using System.Text.Json.Serialization;&#10;using Bernhoeft.GRT.Core.Extensions;&#10;using Bernhoeft.GRT.Teste.Api.Swashbuckle;&#10;using Bernhoeft.GRT.Teste.Application.Requests.Queries.v1;&#10;using FluentValidation;&#10;using FluentValidation.AspNetCore;&#10;using MicroElements.Swashbuckle.FluentValidation.AspNetCore;&#10;using Microsoft.AspNetCore.Http.Features;&#10;using Microsoft.AspNetCore.HttpOverrides;&#10;using Microsoft.EntityFrameworkCore;&#10;using Microsoft.Extensions.Options;&#10;using Swashbuckle.AspNetCore.SwaggerGen;&#10;using Unchase.Swashbuckle.AspNetCore.Extensions.Extensions;&#10;&#10;var builder = WebApplication.CreateBuilder(args);&#10;&#10;if (Debugger.IsAttached)&#10;    builder.Configuration.AddJsonFile(&quot;appsettings.Debugger.json&quot;, true);&#10;&#10;builder.WebHost.UseKestrel(options =&gt;&#10;{&#10;    options.AddServerHeader = false; /* Header com Informações do Servidor. */&#10;    options.Limits.MaxRequestLineSize = 32 * 1024; /* Tamanho máximo do URL (em bytes). */&#10;    options.Limits.MaxRequestBodySize = 50 * 1024 * 1024; /* Tamanho máximo da solicitação (em bytes). */&#10;    options.Limits.MinResponseDataRate = null; /* Taxa mínima de dados de resposta (bytes/segundo). */&#10;    options.Limits.MinRequestBodyDataRate = null; /* Taxa mínima de dados de solicitação (bytes/segundo). */&#10;    if (int.TryParse(Environment.GetEnvironmentVariable(&quot;PORT&quot;), out var port))&#10;        options.ListenAnyIP(port);&#10;});&#10;&#10;// Adicionando os serviços no container.&#10;builder.Services.AddMemoryCache()&#10;                .AddControllers(options =&gt;&#10;                {&#10;                    options.MaxModelBindingCollectionSize = int.MaxValue;&#10;                    options.CacheProfiles.Add(&quot;DefaultCache&quot;, new CacheProfile&#10;                    {&#10;                        Duration = 3600,&#10;                        Location = ResponseCacheLocation.Client&#10;                    });&#10;                })&#10;                .AddJsonOptions(options =&gt;&#10;                {&#10;                    options.JsonSerializerOptions.DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull;&#10;                    options.JsonSerializerOptions.PropertyNamingPolicy = null;&#10;                });&#10;&#10;builder.Services.AddEndpointsApiExplorer();&#10;&#10;// Configurando o versionamento.&#10;builder.Services.AddApiVersioning(p =&gt;&#10;                {&#10;                    p.DefaultApiVersion = new ApiVersion(1, 0);&#10;                    p.ReportApiVersions = true;&#10;                    p.AssumeDefaultVersionWhenUnspecified = true;&#10;                })&#10;                .AddApiExplorer(p =&gt;&#10;                {&#10;                    p.GroupNameFormat = &quot;'Teste API v'VVV&quot;;&#10;                    p.SubstituteApiVersionInUrl = true;&#10;                });&#10;&#10;builder.Services.AddTransient&lt;IConfigureOptions&lt;SwaggerGenOptions&gt;, ConfigureSwaggerOptions&gt;();&#10;builder.Services.AddSwaggerGen(options =&gt;&#10;{&#10;    options.IgnoreObsoleteProperties();&#10;    options.AddGRTSwaggerGenFilters();&#10;    options.AddEnumsWithValuesFixFilters(option =&gt;&#10;    {&#10;        option.ApplySchemaFilter = true;&#10;        option.ApplyParameterFilter = true;&#10;        option.ApplyDocumentFilter = true;&#10;        option.IncludeDescriptions = true;&#10;        option.IncludeXEnumRemarks = true;&#10;        option.DescriptionSource = DescriptionSources.DescriptionAttributesThenXmlComments;&#10;    });&#10;&#10;    Directory.GetFiles(AppContext.BaseDirectory, &quot;*.xml&quot;).ForEach(xmlFile =&gt;&#10;    {&#10;        options.IncludeXmlComments(xmlFile, true);&#10;    });&#10;});&#10;&#10;// Configurando o MediatR.&#10;builder.Services.AddMediatR(options =&gt; options.RegisterServicesFromAssemblyContaining&lt;GetAvisosRequest&gt;());&#10;&#10;// Adicionar Context de Conexão com Banco de Dados SqlServer GRT.&#10;builder.Services.AddDbContext&lt;DbContext&gt;(options =&gt; options.UseInMemoryDatabase(&quot;TesteDb&quot;));&#10;&#10;// Outros Serviços.&#10;builder.Services.RegisterServicesFromAssemblyContaining&lt;GetAvisosRequest&gt;();&#10;&#10;// Adicionando Fluent Validation.&#10;ValidatorOptions.Global.DefaultClassLevelCascadeMode = CascadeMode.Stop;&#10;ValidatorOptions.Global.DefaultRuleLevelCascadeMode = CascadeMode.Stop;&#10;ValidatorOptions.Global.LanguageManager.Culture = new CultureInfo(&quot;pt-BR&quot;);&#10;builder.Services.AddFluentValidationAutoValidation(options =&gt; options.DisableDataAnnotationsValidation = true)&#10;                .AddFluentValidationClientsideAdapters()&#10;                .AddValidatorsFromAssemblyContaining&lt;GetAvisosRequest&gt;();&#10;builder.Services.AddFluentValidationRulesToSwagger();&#10;&#10;// Configure Some Options&#10;builder.Services.Configure&lt;FormOptions&gt;(options =&gt; options.ValueCountLimit = int.MaxValue)&#10;                .Configure&lt;RouteOptions&gt;(options =&gt; options.LowercaseUrls = true);&#10;&#10;// Configurando a Pipeline do HTTP Request.&#10;var app = builder.Build();&#10;app.UseForwardedHeaders(new()&#10;{&#10;    ForwardedHeaders = ForwardedHeaders.XForwardedFor | ForwardedHeaders.XForwardedProto&#10;});&#10;&#10;if (app.Environment.IsDevelopment() || app.Environment.IsStaging() || Debugger.IsAttached)&#10;{&#10;    app.UseSwagger();&#10;    app.UseSwaggerUI(options =&gt;&#10;    {&#10;        var apiVersionDescriptionProvider = app.Services.GetRequiredService&lt;IApiVersionDescriptionProvider&gt;();&#10;        apiVersionDescriptionProvider?.ApiVersionDescriptions?.Reverse().ForEach(description =&gt;&#10;        {&#10;            options.SwaggerEndpoint($&quot;/swagger/{description.GroupName}/swagger.json&quot;, description.GroupName);&#10;        });&#10;&#10;        options.RoutePrefix = string.Empty;&#10;    });&#10;}&#10;&#10;app.UseCors(options =&gt; options.WithOrigins()&#10;                              .AllowAnyHeader()&#10;                              .AllowAnyMethod()&#10;                              .AllowCredentials()&#10;                              .SetIsOriginAllowed(origin =&gt; true));&#10;app.UseHttpsRedirection();&#10;app.UseAuthentication();&#10;app.UseAuthorization();&#10;app.MapControllers();&#10;await app.RunAsync();&#10;&#10;public partial class Program&#10;{ }" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/2-Application/Bernhoeft.GRT.Teste.Application/Handlers/Commands/v1/CreateAvisoHandler.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/2-Application/Bernhoeft.GRT.Teste.Application/Handlers/Commands/v1/CreateAvisoHandler.cs" />
              <option name="originalContent" value="using Bernhoeft.GRT.Core.Enums;&#10;using Bernhoeft.GRT.Core.Interfaces.Results;&#10;using Bernhoeft.GRT.Core.Models;&#10;using Bernhoeft.GRT.Teste.Application.Requests.Commands.v1;&#10;using Bernhoeft.GRT.Teste.Application.Requests.Commands.v1.Validations;&#10;using Bernhoeft.GRT.Teste.Domain.Entities;&#10;using Bernhoeft.GRT.Teste.Domain.Interfaces.Repositories;&#10;using FluentValidation;&#10;using MediatR;&#10;&#10;namespace Bernhoeft.GRT.Teste.Application.Handlers.Commands.v1;&#10;&#10;public class CreateAvisoHandler: IRequestHandler&lt;CreateAvisoRequest, IOperationResult&lt;string&gt;&gt;&#10;{&#10;    private readonly IServiceProvider _serviceProvider;&#10;    private readonly IAvisoRepository _avisoRepository;&#10;    private readonly AbstractValidator&lt;CreateAvisoRequest&gt; _validator;&#10;&#10;    public CreateAvisoHandler(IServiceProvider serviceProvider)&#10;    {&#10;        _serviceProvider = serviceProvider;&#10;        _avisoRepository = (IAvisoRepository)_serviceProvider.GetService(typeof(IAvisoRepository));&#10;        _validator = new CreateAvisoValidator();&#10;    }&#10;&#10;    public async Task&lt;IOperationResult&lt;string&gt;&gt; Handle(CreateAvisoRequest request, CancellationToken cancellationToken)&#10;    {&#10;        var validationResult = await _validator.ValidateAsync(request, cancellationToken);&#10;        if (!validationResult.IsValid)&#10;            return OperationResult&lt;string&gt;.Return(CustomHttpStatusCode.BadRequest, validationResult.Errors.ToArray().ToString());&#10;&#10;        var aviso = new AvisoEntity()&#10;        {&#10;            Titulo = request.Titulo,&#10;            Mensagem = request.Mensagem,&#10;            DataAtualizacao = DateTime.UtcNow,&#10;            Ativo = true&#10;        };&#10;        await _avisoRepository.CriarAvisoAsync(aviso, cancellationToken);&#10;&#10;        return OperationResult&lt;string&gt;.ReturnCreated();&#10;    }&#10;}" />
              <option name="updatedContent" value="using Bernhoeft.GRT.Core.Enums;&#10;using Bernhoeft.GRT.Core.Interfaces.Results;&#10;using Bernhoeft.GRT.Core.Models;&#10;using Bernhoeft.GRT.Teste.Application.Requests.Commands.v1;&#10;using Bernhoeft.GRT.Teste.Application.Requests.Commands.v1.Validations;&#10;using Bernhoeft.GRT.Teste.Domain.Entities;&#10;using Bernhoeft.GRT.Teste.Domain.Interfaces.Repositories;&#10;using FluentValidation;&#10;using MediatR;&#10;&#10;namespace Bernhoeft.GRT.Teste.Application.Handlers.Commands.v1;&#10;&#10;public class CreateAvisoHandler : IRequestHandler&lt;CreateAvisoRequest, IOperationResult&lt;string&gt;&gt;&#10;{&#10;    private readonly IAvisoRepository _avisoRepository;&#10;&#10;    public CreateAvisoHandler(IServiceProvider serviceProvider)&#10;    {&#10;        _avisoRepository = (IAvisoRepository)serviceProvider.GetService(typeof(IAvisoRepository));&#10;    }&#10;&#10;    public async Task&lt;IOperationResult&lt;string&gt;&gt; Handle(CreateAvisoRequest request, CancellationToken cancellationToken)&#10;    {&#10;        var validator = new CreateAvisoValidator();&#10;        var validationResult = await validator.ValidateAsync(request, cancellationToken);&#10;        if (!validationResult.IsValid)&#10;            return OperationResult&lt;string&gt;.Return(CustomHttpStatusCode.BadRequest, string.Join(&quot;; &quot;, validationResult.Errors.Select(e =&gt; e.ErrorMessage)));&#10;&#10;        var aviso = new AvisoEntity()&#10;        {&#10;            Titulo = request.Titulo,&#10;            Mensagem = request.Mensagem,&#10;            DataAtualizacao = DateTime.UtcNow,&#10;            Ativo = true&#10;        };&#10;        await _avisoRepository.CriarAvisoAsync(aviso, cancellationToken);&#10;&#10;        return OperationResult&lt;string&gt;.ReturnCreated();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/2-Application/Bernhoeft.GRT.Teste.Application/Handlers/Commands/v1/DeleteAvisoHandler.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/2-Application/Bernhoeft.GRT.Teste.Application/Handlers/Commands/v1/DeleteAvisoHandler.cs" />
              <option name="originalContent" value="using Bernhoeft.GRT.Core.Enums;&#10;using Bernhoeft.GRT.Core.Interfaces.Results;&#10;using Bernhoeft.GRT.Core.Models;&#10;using Bernhoeft.GRT.Teste.Application.Exceptions;&#10;using Bernhoeft.GRT.Teste.Application.Requests.Commands.v1;&#10;using Bernhoeft.GRT.Teste.Application.Requests.Commands.v1.Validations;&#10;using Bernhoeft.GRT.Teste.Domain.Interfaces.Repositories;&#10;using FluentValidation;&#10;using MediatR;&#10;&#10;namespace Bernhoeft.GRT.Teste.Application.Handlers.Commands.v1;&#10;&#10;public class DeleteAvisoHandler: IRequestHandler&lt;DeleteAvisoRequest, IOperationResult&lt;string&gt;&gt;&#10;{&#10;    private readonly IServiceProvider _serviceProvider;&#10;    private readonly IAvisoRepository _avisoRepository;&#10;    private readonly AbstractValidator&lt;DeleteAvisoRequest&gt; _validator;&#10;&#10;    public DeleteAvisoHandler(IServiceProvider serviceProvider)&#10;    {&#10;        _serviceProvider = serviceProvider;&#10;        _avisoRepository = (IAvisoRepository)_serviceProvider.GetService(typeof(IAvisoRepository));&#10;        _validator = new DeleteAvisoValidator();&#10;    }&#10;&#10;    public async Task&lt;IOperationResult&lt;string&gt;&gt; Handle(DeleteAvisoRequest request, CancellationToken cancellationToken)&#10;    {&#10;        var validationResult = await _validator.ValidateAsync(request, cancellationToken);&#10;        if (!validationResult.IsValid)&#10;            return OperationResult&lt;string&gt;.Return(CustomHttpStatusCode.BadRequest, validationResult.Errors.ToArray().ToString());&#10;&#10;        var avisoExistente = await _avisoRepository.ObterAvisoPorIdAsync(request.Id, cancellationToken);&#10;        if (avisoExistente == null) return OperationResult&lt;string&gt;.ReturnNotFound();&#10;&#10;        avisoExistente.Ativo = false;&#10;        avisoExistente.DataAtualizacao = new DateTime();&#10;&#10;        await _avisoRepository.AtualizarAvisoAsync(avisoExistente);&#10;        return OperationResult&lt;string&gt;.Return(CustomHttpStatusCode.Ok, &quot;Aviso deletado com sucesso.&quot;);&#10;    }&#10;}" />
              <option name="updatedContent" value="using Bernhoeft.GRT.Core.Enums;&#10;using Bernhoeft.GRT.Core.Interfaces.Results;&#10;using Bernhoeft.GRT.Core.Models;&#10;using Bernhoeft.GRT.Teste.Application.Exceptions;&#10;using Bernhoeft.GRT.Teste.Application.Requests.Commands.v1;&#10;using Bernhoeft.GRT.Teste.Application.Requests.Commands.v1.Validations;&#10;using Bernhoeft.GRT.Teste.Domain.Interfaces.Repositories;&#10;using FluentValidation;&#10;using MediatR;&#10;&#10;namespace Bernhoeft.GRT.Teste.Application.Handlers.Commands.v1;&#10;&#10;public class DeleteAvisoHandler : IRequestHandler&lt;DeleteAvisoRequest, IOperationResult&lt;string&gt;&gt;&#10;{&#10;    private readonly IAvisoRepository _avisoRepository;&#10;&#10;    public DeleteAvisoHandler(IServiceProvider serviceProvider)&#10;    {&#10;        _avisoRepository = (IAvisoRepository)serviceProvider.GetService(typeof(IAvisoRepository));&#10;    }&#10;&#10;    public async Task&lt;IOperationResult&lt;string&gt;&gt; Handle(DeleteAvisoRequest request, CancellationToken cancellationToken)&#10;    {&#10;        var validator = new DeleteAvisoValidator();&#10;        var validationResult = await validator.ValidateAsync(request, cancellationToken);&#10;        if (!validationResult.IsValid)&#10;            return OperationResult&lt;string&gt;.Return(CustomHttpStatusCode.BadRequest, string.Join(&quot;; &quot;, validationResult.Errors.Select(e =&gt; e.ErrorMessage)));&#10;&#10;        var avisoExistente = await _avisoRepository.ObterAvisoPorIdAsync(request.Id, cancellationToken);&#10;        if (avisoExistente == null) return OperationResult&lt;string&gt;.ReturnNotFound();&#10;&#10;        avisoExistente.Ativo = false;&#10;        avisoExistente.DataAtualizacao = DateTime.UtcNow;&#10;&#10;        await _avisoRepository.AtualizarAvisoAsync(avisoExistente);&#10;        return OperationResult&lt;string&gt;.Return(CustomHttpStatusCode.Ok, &quot;Aviso deletado com sucesso.&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/2-Application/Bernhoeft.GRT.Teste.Application/Handlers/Commands/v1/UpdateAvisoHandler.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/2-Application/Bernhoeft.GRT.Teste.Application/Handlers/Commands/v1/UpdateAvisoHandler.cs" />
              <option name="originalContent" value="using Bernhoeft.GRT.Core.Enums;&#10;using Bernhoeft.GRT.Core.Interfaces.Results;&#10;using Bernhoeft.GRT.Core.Models;&#10;using Bernhoeft.GRT.Teste.Application.Exceptions;&#10;using Bernhoeft.GRT.Teste.Application.Requests.Commands.v1;&#10;using Bernhoeft.GRT.Teste.Application.Requests.Commands.v1.Validations;&#10;using Bernhoeft.GRT.Teste.Domain.Interfaces.Repositories;&#10;using FluentValidation;&#10;using MediatR;&#10;&#10;namespace Bernhoeft.GRT.Teste.Application.Handlers.Commands.v1;&#10;&#10;public class UpdateAvisoHandler: IRequestHandler&lt;UpdateAvisoRequest, IOperationResult&lt;string&gt;&gt;&#10;{&#10;    private readonly IServiceProvider _serviceProvider;&#10;    private readonly IAvisoRepository _avisoRepository;&#10;    private readonly AbstractValidator&lt;UpdateAvisoRequest&gt; _validator;&#10;&#10;    public UpdateAvisoHandler(IServiceProvider serviceProvider)&#10;    {&#10;        _serviceProvider = serviceProvider;&#10;        _avisoRepository = (IAvisoRepository)_serviceProvider.GetService(typeof(IAvisoRepository));&#10;        _validator = new UpdateAvisoValidator();&#10;    }&#10;&#10;    public async Task&lt;IOperationResult&lt;string&gt;&gt; Handle(UpdateAvisoRequest request, CancellationToken cancellationToken)&#10;    {&#10;        var validationResult = await _validator.ValidateAsync(request, cancellationToken);&#10;        if (!validationResult.IsValid)&#10;            return OperationResult&lt;string&gt;.Return(CustomHttpStatusCode.Ok, validationResult.Errors.ToArray().ToString());&#10;&#10;        var avisoExistente = await _avisoRepository.ObterAvisoPorIdAsync(request.Id, cancellationToken);&#10;        if (avisoExistente == null) return OperationResult&lt;string&gt;.ReturnNotFound();&#10;&#10;        avisoExistente.DataAtualizacao = new DateTime();&#10;        await _avisoRepository.AtualizarAvisoAsync(avisoExistente);&#10;        return OperationResult&lt;string&gt;.Return(CustomHttpStatusCode.Ok, &quot;Aviso atualizado com sucesso.&quot;);&#10;    }&#10;}" />
              <option name="updatedContent" value="using Bernhoeft.GRT.Core.Enums;&#10;using Bernhoeft.GRT.Core.Interfaces.Results;&#10;using Bernhoeft.GRT.Core.Models;&#10;using Bernhoeft.GRT.Teste.Application.Exceptions;&#10;using Bernhoeft.GRT.Teste.Application.Requests.Commands.v1;&#10;using Bernhoeft.GRT.Teste.Application.Requests.Commands.v1.Validations;&#10;using Bernhoeft.GRT.Teste.Domain.Interfaces.Repositories;&#10;using FluentValidation;&#10;using MediatR;&#10;&#10;namespace Bernhoeft.GRT.Teste.Application.Handlers.Commands.v1;&#10;&#10;public class UpdateAvisoHandler : IRequestHandler&lt;UpdateAvisoRequest, IOperationResult&lt;string&gt;&gt;&#10;{&#10;    private readonly IAvisoRepository _avisoRepository;&#10;&#10;    public UpdateAvisoHandler(IServiceProvider serviceProvider)&#10;    {&#10;        _avisoRepository = (IAvisoRepository)serviceProvider.GetService(typeof(IAvisoRepository));&#10;    }&#10;&#10;    public async Task&lt;IOperationResult&lt;string&gt;&gt; Handle(UpdateAvisoRequest request, CancellationToken cancellationToken)&#10;    {&#10;        var validator = new UpdateAvisoValidator();&#10;        var validationResult = await validator.ValidateAsync(request, cancellationToken);&#10;        if (!validationResult.IsValid)&#10;            return OperationResult&lt;string&gt;.Return(CustomHttpStatusCode.BadRequest, string.Join(&quot;; &quot;, validationResult.Errors.Select(e =&gt; e.ErrorMessage)));&#10;&#10;        var avisoExistente = await _avisoRepository.ObterAvisoPorIdAsync(request.Id, cancellationToken);&#10;        if (avisoExistente == null) return OperationResult&lt;string&gt;.ReturnNotFound();&#10;&#10;        avisoExistente.Ativo = false;&#10;        avisoExistente.DataAtualizacao = DateTime.UtcNow;&#10;&#10;        await _avisoRepository.AtualizarAvisoAsync(avisoExistente);&#10;        return OperationResult&lt;string&gt;.Return(CustomHttpStatusCode.Ok, &quot;Aviso atualizado com sucesso.&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/2-Application/Bernhoeft.GRT.Teste.Application/Handlers/Queries/v1/GetAvisoByIdHandler.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/2-Application/Bernhoeft.GRT.Teste.Application/Handlers/Queries/v1/GetAvisoByIdHandler.cs" />
              <option name="originalContent" value="using Bernhoeft.GRT.Core.Enums;&#10;using Bernhoeft.GRT.Core.Interfaces.Results;&#10;using Bernhoeft.GRT.Core.Models;&#10;using Bernhoeft.GRT.Teste.Application.Requests.Queries.v1;&#10;using Bernhoeft.GRT.Teste.Application.Requests.Queries.v1.Validations;&#10;using Bernhoeft.GRT.Teste.Application.Responses.Queries.v1;&#10;using Bernhoeft.GRT.Teste.Domain.Interfaces.Repositories;&#10;using FluentValidation;&#10;using MediatR;&#10;&#10;namespace Bernhoeft.GRT.Teste.Application.Handlers.Queries.v1;&#10;&#10;public class GetAvisoByIdHandler : IRequestHandler&lt;GetAvisoByIdRequest, IOperationResult&lt;GetAvisosResponse&gt;&gt;&#10;{&#10;    private readonly IServiceProvider _serviceProvider;&#10;    private IAvisoRepository _avisoRepository;&#10;    private AbstractValidator&lt;GetAvisoByIdRequest&gt; _validator;&#10;&#10;    public GetAvisoByIdHandler(IServiceProvider serviceProvider)&#10;    {&#10;        _serviceProvider = serviceProvider;&#10;        _avisoRepository = (IAvisoRepository)_serviceProvider.GetService(typeof(IAvisoRepository));&#10;        _validator = new GetAvisoByIdValidator();&#10;    }&#10;&#10;    public async Task&lt;IOperationResult&lt;GetAvisosResponse&gt;&gt; Handle(GetAvisoByIdRequest request, CancellationToken cancellationToken)&#10;    {&#10;        var validationResult = await _validator.ValidateAsync(request, cancellationToken);&#10;        if (!validationResult.IsValid)&#10;            return OperationResult&lt;GetAvisosResponse&gt;.ReturnBadRequest();&#10;&#10;        var result = await _avisoRepository.ObterAvisoPorIdAsync(request.Id, cancellationToken);&#10;        if (result == null)&#10;            return OperationResult&lt;GetAvisosResponse&gt;.ReturnNoContent();&#10;&#10;        var response = (GetAvisosResponse)result;&#10;        return OperationResult&lt;GetAvisosResponse&gt;.ReturnOk(response);&#10;    }&#10;}" />
              <option name="updatedContent" value="using Bernhoeft.GRT.Core.Enums;&#10;using Bernhoeft.GRT.Core.Interfaces.Results;&#10;using Bernhoeft.GRT.Core.Models;&#10;using Bernhoeft.GRT.Teste.Application.Requests.Queries.v1;&#10;using Bernhoeft.GRT.Teste.Application.Requests.Queries.v1.Validations;&#10;using Bernhoeft.GRT.Teste.Application.Responses.Queries.v1;&#10;using Bernhoeft.GRT.Teste.Domain.Interfaces.Repositories;&#10;using FluentValidation;&#10;using MediatR;&#10;&#10;namespace Bernhoeft.GRT.Teste.Application.Handlers.Queries.v1;&#10;&#10;public class GetAvisoByIdHandler : IRequestHandler&lt;GetAvisoByIdRequest, IOperationResult&lt;GetAvisosResponse&gt;&gt;&#10;{&#10;    private readonly IAvisoRepository _avisoRepository;&#10;&#10;    public GetAvisoByIdHandler(IServiceProvider serviceProvider)&#10;    {&#10;        _avisoRepository = (IAvisoRepository)serviceProvider.GetService(typeof(IAvisoRepository));&#10;    }&#10;&#10;    public async Task&lt;IOperationResult&lt;GetAvisosResponse&gt;&gt; Handle(GetAvisoByIdRequest request, CancellationToken cancellationToken)&#10;    {&#10;        var validator = new GetAvisoByIdValidator();&#10;        var validationResult = await validator.ValidateAsync(request, cancellationToken);&#10;        if (!validationResult.IsValid)&#10;            return OperationResult&lt;GetAvisosResponse&gt;.ReturnBadRequest();&#10;&#10;        var result = await _avisoRepository.ObterAvisoPorIdAsync(request.Id, cancellationToken);&#10;        if (result == null)&#10;            return OperationResult&lt;GetAvisosResponse&gt;.ReturnNoContent();&#10;&#10;        var response = (GetAvisosResponse)result;&#10;        return OperationResult&lt;GetAvisosResponse&gt;.ReturnOk(response);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/3-Domain/Bernhoeft.GRT.Teste.Domain/Interfaces/Repositories/IAvisoRepository.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/3-Domain/Bernhoeft.GRT.Teste.Domain/Interfaces/Repositories/IAvisoRepository.cs" />
              <option name="originalContent" value="&#10;&#10;using Bernhoeft.GRT.Core.EntityFramework.Domain.Interfaces;&#10;using Bernhoeft.GRT.Teste.Domain.Entities;&#10;&#10;namespace Bernhoeft.GRT.Teste.Domain.Interfaces.Repositories&#10;{&#10;    public interface IAvisoRepository : IRepository&lt;AvisoEntity&gt;&#10;    {&#10;        Task CriarAvisoAsync(AvisoEntity aviso, CancellationToken cancellationToken = default);&#10;        Task AtualizarAvisoAsync(AvisoEntity aviso);&#10;        Task DeletarAvisoAsync(int id, CancellationToken cancellationToken);&#10;        Task&lt;AvisoEntity&gt; ObterAvisoPorIdAsync(int id, CancellationToken cancellationToken);&#10;        Task&lt;List&lt;AvisoEntity&gt;&gt; ObterTodosAvisosAsync();&#10;    }&#10;}" />
              <option name="updatedContent" value="using Bernhoeft.GRT.Core.EntityFramework.Domain.Interfaces;&#10;using Bernhoeft.GRT.Teste.Domain.Entities;&#10;&#10;namespace Bernhoeft.GRT.Teste.Domain.Interfaces.Repositories&#10;{&#10;    public interface IAvisoRepository : IRepository&lt;AvisoEntity&gt;&#10;    {&#10;        Task CriarAvisoAsync(AvisoEntity aviso, CancellationToken cancellationToken = default);&#10;        Task AtualizarAvisoAsync(AvisoEntity aviso);&#10;        Task DeletarAvisoAsync(int id, CancellationToken cancellationToken);&#10;        Task&lt;AvisoEntity&gt; ObterAvisoPorIdAsync(int id, CancellationToken cancellationToken);&#10;        Task&lt;List&lt;AvisoEntity&gt;&gt; ObterTodosAvisosAsync();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="updatedContent" value="# Bernhoeft.GRT.Teste&#10;&#10;## Resumo do Projeto&#10;&#10;Este projeto é uma API desenvolvida em ASP.NET Core, utilizando o padrão CQRS (Command Query Responsibility Segregation) e MediatR para separação de comandos e consultas. O objetivo é fornecer uma estrutura básica para gerenciamento de avisos, com persistência em banco de dados InMemory (pode ser facilmente adaptado para outros bancos via Entity Framework Core).&#10;&#10;### Principais Tecnologias Utilizadas&#10;- ASP.NET Core 9&#10;- Entity Framework Core (InMemory)&#10;- MediatR&#10;- FluentValidation&#10;- Swashbuckle (Swagger)&#10;- API Versioning&#10;&#10;## Estrutura do Projeto&#10;- **1-Presentation**: Camada de apresentação (API)&#10;- **2-Application**: Camada de aplicação (Handlers, Requests, Responses)&#10;- **3-Domain**: Camada de domínio (Entidades, Interfaces)&#10;- **4-Infra**: Infraestrutura (Repositórios, Mapeamentos)&#10;- **0-Tests**: Testes de integração&#10;&#10;## Endpoints Disponíveis&#10;&#10;### Avisos&#10;&#10;#### `GET /api/v1/avisos`&#10;Retorna a lista de avisos cadastrados.&#10;&#10;#### `GET /api/v1/avisos/{id}`&#10;Retorna um aviso específico pelo ID.&#10;&#10;#### `POST /api/v1/avisos`&#10;Cria um novo aviso.&#10;- Body: JSON com os dados do aviso.&#10;&#10;#### `PUT /api/v1/avisos/{id}`&#10;Atualiza um aviso existente.&#10;- Body: JSON com os dados atualizados.&#10;&#10;#### `DELETE /api/v1/avisos/{id}`&#10;Remove um aviso pelo ID.&#10;&#10;## Implementação&#10;&#10;- **CQRS**: Handlers separados para comandos (criação, atualização, remoção) e queries (busca).&#10;- **MediatR**: Utilizado para orquestrar a comunicação entre controllers e handlers.&#10;- **FluentValidation**: Validação de requests antes do processamento.&#10;- **Swagger**: Documentação automática dos endpoints, disponível em `/swagger`.&#10;- **Injeção de Dependência**: Configurada via `Program.cs`.&#10;- **Banco de Dados**: Utiliza InMemory para facilitar testes e desenvolvimento.&#10;&#10;## Como Executar&#10;&#10;1. Restaure os pacotes NuGet:&#10;   ```bash&#10;   dotnet restore&#10;   ```&#10;2. Execute a aplicação:&#10;   ```bash&#10;   dotnet run --project 1-Presentation/Bernhoeft.GRT.Teste.Api/Bernhoeft.GRT.Teste.Api.csproj&#10;   ```&#10;3. Acesse a documentação Swagger em: [http://localhost:5000/swagger](http://localhost:5000/swagger)&#10;&#10;## Observações&#10;- O projeto está pronto para ser adaptado para outros bancos de dados, bastando alterar a configuração do `DbContext`.&#10;- Os testes de integração estão localizados na pasta `0-Tests`.&#10;&#10;---&#10;&#10;&gt; Projeto desenvolvido para fins de estudo e demonstração de arquitetura limpa com CQRS e MediatR.&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>